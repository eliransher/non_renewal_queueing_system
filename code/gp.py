# -*- coding: utf-8 -*-
"""project_gp_regression_Q (3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E6JPr8ecZI4d_71ozFnjnY4rIF4oa-20
"""

# import plotly.graph_objects as go
import numpy as np
# from google.colab import drive
# drive.mount('/content/drive')
import pymc as pm
import arviz as az
import pickle as pkl
import pandas as pd
import matplotlib.pyplot as plt

"""# ER analysis

### You are now incharge of the a queueing system in the ER, which operates 24/7.

### Patients are arriving with time-dependant rate. The service rate on the other is constanst at 15 patients per hour. We split the week into a 168 grid, where we have 7 days and 24 hours within a single day. For each cell in the grid, that is a combination of a day and an hour we have different service rate.

### We wish to analyze the expceted number of pateints in the ER as function of time. We have an event log of customers arriving to the ER and departing the ER. We have data collection of 1000 days.

### The data is a dictionary of 1000 different days numbered from 0 to 999. Each one is an event log of a different day.

### The columns of the data are:
#### 1. Customer_id - identifier of the arriving customer
#### 2. Time-stamp  - the time the event occurs. The units are in hours. The $i^{th}$ hour is the number of hours elapsed since 0:00 of that day.
#### 3. Type - event type, Arrival or Departure.
#### 4. num_cust - number of cusotmers in the system
#### 5. day - a numerical value of the day: {0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Shabbat}
#### 6. hour - the hour of the day, an integer from 0 to 23. If it is 0 then the hour is between midnight to 01:00.
#### 7. day_name - the name of the day of the week.


## Each day starts with 0 patients at 0:00.

# The goal of this task is to find the arrival rate for each hour of the day.

## From the data, one can use classic stastical methods in order to estimate the arrival rate for each hour of the week. The problem is that there is missing data, we do not have the data in the event log for all hours.

### The main idea is to estimate the arrival rate for time zones in which we have data and then using GP regression for time zones the data was missing.

### This part is split into three parts.

"""

event_log_single_ser = pkl.load(open('/content/drive/MyDrive/PROJECT_BAYES/event_log_part_2.pkl', 'rb'))

event_log_single_ser[0].head()

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

##############################################
###### Funcitons #############################
##############################################

def model(n, t, lambda_t, mu):
    """
    Differential equation for the M(t)/M/1 queue:
    dn/dt = lambda(t) - mu * (1 - p0(t))
    where p0(t) is the probability of 0 customers in the system.

    For approximation, we use the relation p0 ≈ max(0, 1 - n) when n < 1
    and p0 ≈ 0 when n ≥ 1.
    """
    # Current arrival rate based on time
    current_lambda = piecewise_lambda(t, lambda_t)

    # Approximate p0
    if n < 1:
        p0 = max(0, 1 - n)
    else:
        p0 = 0

    dndt = current_lambda - mu * (1 - p0)
    return dndt

def piecewise_lambda(t, lambda_t):
    """
    Returns the arrival rate at time t based on piecewise constant definition.
    lambda_t is a list of tuples (start_time, end_time, rate)
    """
    for (start, end, rate) in lambda_t:
        if start <= t < end:
            return rate
    return 0  # default if outside all intervals


def compute_MSE(n_true, n):
  return ((n_true - n)**2).mean().item()


def create_tuples(df_sorted):

    all_tuples =  []
    for row_ind in range(df_sorted.shape[0]):
        hour = df_sorted.loc[row_ind, 'hour']
        day = df_sorted.loc[row_ind, 'day']
        rate = df_sorted.loc[row_ind, 'rate'].item()
        tot_time = hour + 24*day
        all_tuples.append((tot_time.item(),tot_time.item()+1, rate))

    return all_tuples


def plot_results(df_res, n_true):

  # Parameters
    mu = 15.0  # service rate
    all_tuples = create_tuples(df_res)
    lambda_t = all_tuples  #[(0, 10, 5.0), (10,30,1) ,(30, 50, 0.2)]  # piecewise arrival rates
    # lambda_t_true = all_tuples_true

    # Time points
    t = np.linspace(0, 168, 1000)

    # Initial condition: empty system
    n0 = 0.0
    # Solve the ODE
    n = odeint(model, n0, t, args=(lambda_t, mu))
    # Plot results
    plt.figure(figsize=(10, 6))
    plt.plot(t, n, '-', color = 'orange', linewidth=2, label = 'Predicted')
    plt.plot(t, n_true,  linewidth=2, label = 'True', linestyle = '--')
    plt.xlabel('Time')
    plt.ylabel('Number of customers in system')
    plt.title('Queue analysis')
    plt.legend()
    plt.xlabel('Time')
    plt.ylabel('Expected number of customers in system')
    plt.grid(True)

    print('The MSE is: ', compute_MSE(n_true, n))



    plt.show()

"""## Part 1:

### Tasks:

### 1. Do Bayesian anaysis for the number of arriving customers and its distirbution for the time between 0:00 to 1:00.
### 2. What did you use as the likelihood function and why?
### 3. Do  posterior predicitive anaysis to assert that the chosen likelihood distribution is valid.
### 4. According to the resulted anaysis, how certain are you about the average arrival prediction?

### 5. What is the estimated arrival rate? Give a single values based on the posterior.

"""

# Your code
#  סינון הנתונים
all_days = pd.concat([event_log_single_ser[day] for day in range(1000)], keys=range(1000), names=['day'])
arrival_counts = all_days[(all_days['Type'] == 'Arrival') & (all_days['hour'] == 0)] \
    .groupby(level='day').size().reindex(range(1000), fill_value=0).values

# בדיקת ממוצע הנתונים
print(f"ממוצע הגעות לפי הנתונים: {np.mean(arrival_counts):.2f}")

#  מודל בייסיאני
with pm.Model() as model:
    lam = pm.Gamma('lam', alpha=1, beta=1)  # prior פחות אינפורמטיבי
    obs = pm.Poisson('obs', mu=lam, observed=arrival_counts)
    trace = pm.sample(2000, tune=1000, random_seed=42, cores=2, progressbar=True)

# סיכום הפוסטריור
summary = az.summary(trace, hdi_prob=0.94)
print(summary)
az.plot_posterior(trace, var_names=['lam'], hdi_prob=0.94)
plt.title('התפלגות הפוסטריור של קצב ההגעה (λ)')
plt.show()
lambda_mean = trace.posterior['lam'].mean().item()
print(f"קצב ההגעה המשוער (λ): {lambda_mean:.2f} מטופלים לשעה")

#  Posterior Predictive Check
with model:
    ppc = pm.sample_posterior_predictive(trace, random_seed=42)
az.plot_ppc(ppc, num_pp_samples=100)
plt.title('Posterior Predictive Check (PPC)')
plt.show()
plt.hist(arrival_counts, bins=range(int(max(arrival_counts)+2)), alpha=0.5, label='Observed', density=True)
plt.hist(ppc.posterior_predictive['obs'].values.flatten(), bins=range(int(max(arrival_counts)+2)), alpha=0.5, label='Posterior Predictive', density=True)
plt.xlabel('Number of arrivals')
plt.ylabel('Density')
plt.title('Comparison of observed and simulated distributions')
plt.legend()
plt.show()

#  השוואת ממוצעים
observed_mean = arrival_counts.mean()
ppc_mean = ppc.posterior_predictive['obs'].mean().item()
print(f"ממוצע הנתונים המקוריים: {observed_mean:.2f}")
print(f"ממוצע הנתונים המנובאים (PPC): {ppc_mean:.2f}")

"""## Part 2:
### We have 24 hours a day, 7 days a week. In total we have a grid of 168 cells.

### We wish to map the average arrival rate at each time cell.

### In the dataset we have missing parts, some cells in the grid are missing. Your job is to fill the grid.

## Tasks:

### 1. Extract the arrival rate (taking the average time is sufficient, no need  for extra bayesian analysis) per each cell you do have data.
### 2. Use GP regression for completing the average arrival time for the rest of the grid.
### 3. Plot on a 3D plot which contains:
#### a. Scatter plot of the data that was esitmated from data.
#### b. Scatter plot of the data that was esitmated from GP regression.
#### c. Surface plot of the GP regression.

### 4. What is the probability that the arrival rate between 18:00 to 19:00, on Shabbat, will be between 9 to 10 pateints per hour?
### 5. Please give full specification of the Gauusian distribution of the arrival rate on Monday between 18:00 to 19:00 and Monday between 19:00 to 20:00.
### 6. What is the correlation between the arrival rate at Sunday between 07:00 to 08:00 and Sunday between 08:00 to 09:00?
### What is the correlation between the arrival rate at Sunday between 07:00 to 08:00 and Sunday between 19:00 to 20:00?
### Which correlation value is larger? does this result make sense?
"""

import pandas as pd
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
# import plotly.graph_objects as go
from scipy.stats import norm
import pickle as pkl

# טעינת הנתונים
event_log_single_ser = pkl.load(open(r'C:\Users\Eshel\workspace\Bayesian_programming\project_football\notebooks/event_log_part_2.pkl', 'rb'))

# חישוב קצבי הגעה
def extract_arrival_rates(event_log):
    arrival_counts = np.zeros((7, 24))
    days_counted = np.zeros((7, 24))
    for day_idx, df in event_log.items():
        arrivals = df[df['Type'] == 'Arrival']
        for _, row in arrivals.iterrows():
            day = row['day']
            hour = row['hour']
            arrival_counts[day, hour] += 1
            days_counted[day, hour] = min(days_counted[day, hour] + 1, 1000)
    arrival_rates = np.divide(arrival_counts, days_counted, where=days_counted != 0)
    rates_df = pd.DataFrame([(day, hour, arrival_rates[day, hour]) for day in range(7) for hour in range(24) if days_counted[day, hour] > 0],
                           columns=['day', 'hour', 'rate'])
    return rates_df, arrival_counts, days_counted

rates_df, arrival_counts, days_counted = extract_arrival_rates(event_log_single_ser)

# חישוב סטיית תקן
std_data = np.zeros((7, 24), dtype=float)
for day in range(7):
    for hour in range(24):
        if days_counted[day, hour] > 1:
            daily_arrivals = [df[(df['day'] == day) & (df['hour'] == hour) & (df['Type'] == 'Arrival')].shape[0]
                            for df in event_log_single_ser.values()]
            if daily_arrivals and len(daily_arrivals) > 1:
                std_data[day, hour] = np.std(daily_arrivals) / np.sqrt(days_counted[day, hour])

# רגרסיית GP
def perform_gp_regression(rates_df, std_data):
    X = rates_df[['day', 'hour']].values
    y = rates_df['rate'].values

    days = np.arange(7)
    hours = np.arange(24)
    day_grid, hour_grid = np.meshgrid(days, hours)
    X_full = np.vstack([day_grid.ravel(), hour_grid.ravel()]).T

    kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2))
    gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42)
    gp.fit(X, y)

    y_pred, y_std = gp.predict(X_full, return_std=True)

    full_rates_df = pd.DataFrame({
        'day': X_full[:, 0],
        'hour': X_full[:, 1],
        'rate': y_pred,
        'std': y_std
    })
    full_rates_df['source'] = 'GP'
    for idx, row in rates_df.iterrows():
        mask = (full_rates_df['day'] == row['day']) & (full_rates_df['hour'] == row['hour'])
        full_rates_df.loc[mask, 'rate'] = row['rate']
        full_rates_df.loc[mask, 'std'] = std_data[int(row['day']), int(row['hour'])]
        full_rates_df.loc[mask, 'source'] = 'Data'

    return full_rates_df, gp

full_rates_df, gp_model = perform_gp_regression(rates_df, std_data)

# גרף תלת-ממדי
def plot_3d(full_rates_df):
    data_points = full_rates_df[full_rates_df['source'] == 'Data']
    gp_points = full_rates_df[full_rates_df['source'] == 'GP']

    scatter_data = go.Scatter3d(
        x=data_points['day'],
        y=data_points['hour'],
        z=data_points['rate'],
        mode='markers',
        name='Estimated from Data',
        error_z=dict(
            type='data',
            array=data_points['std'].values,
            visible=True
        ),
        marker=dict(size=5, color='blue')
    )

    scatter_gp = go.Scatter3d(
        x=gp_points['day'],
        y=gp_points['hour'],
        z=gp_points['rate'],
        mode='markers',
        name='Estimated from GP',
        marker=dict(size=5, color='red')
    )

    days = np.arange(7)
    hours = np.arange(24)
    day_grid, hour_grid = np.meshgrid(days, hours)
    rates_grid = full_rates_df['rate'].values.reshape(24, 7)

    surface = go.Surface(
        x=days,
        y=hours,
        z=rates_grid,
        name='GP Surface',
        colorscale='Viridis',
        opacity=0.7
    )

    fig = go.Figure(data=[scatter_data, scatter_gp, surface])
    fig.update_layout(
        title='Arrival Rates: Data vs GP Regression',
        scene=dict(
            xaxis_title='Day',
            yaxis_title='Hour',
            zaxis_title='Arrival Rate (patients/hour)',
            xaxis=dict(tickvals=list(range(7)), ticktext=['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Shabbat']),
            yaxis=dict(tickvals=list(range(24))),
            camera=dict(
                eye=dict(x=1.5, y=1.5, z=0.5)
            )
        ),
        showlegend=True
    )
    fig.show()

plot_3d(full_rates_df)

# חישוב הסתברות
def prob_arrival_rate(day, hour, lower_bound, upper_bound, full_rates_df):
    row = full_rates_df[(full_rates_df['day'] == day) & (full_rates_df['hour'] == hour)]
    mean_rate = row['rate'].values[0]
    std_rate = row['std'].values[0]

    if std_rate == 0:
        return 1.0 if lower_bound <= mean_rate <= upper_bound else 0.0
    else:
        prob = norm.cdf(upper_bound, mean_rate, std_rate) - norm.cdf(lower_bound, mean_rate, std_rate)
        return prob

prob_shabbat_18_19 = prob_arrival_rate(day=6, hour=18, lower_bound=9, upper_bound=10, full_rates_df=full_rates_df)
print(f"ההסתברות שקצב ההגעה בשבת בין 18:00 ל-19:00 יהיה בין 9 ל-10 מטופלים לשעה היא: {prob_shabbat_18_19:.4f}")

# חישוב התפלגות גאוסית
def gaussian_specification(day, hour, full_rates_df):
    row = full_rates_df[(full_rates_df['day'] == day) & (full_rates_df['hour'] == hour)]
    mean_rate = row['rate'].values[0]
    std_rate = row['std'].values[0]
    return mean_rate, std_rate

mean_18_19, std_18_19 = gaussian_specification(day=1, hour=18, full_rates_df=full_rates_df)
print(f"יום שני, 18:00-19:00: התפלגות גאוסית עם ממוצע = {mean_18_19:.2f}, סטיית תקן = {std_18_19:.2f}")
mean_19_20, std_19_20 = gaussian_specification(day=1, hour=19, full_rates_df=full_rates_df)
print(f"יום שני, 19:00-20:00: התפלגות גאוסית עם ממוצע = {mean_19_20:.2f}, סטיית תקן = {std_19_20:.2f}")

# חישוב קורלציות
def compute_correlations(gp_model, day1, hour1, day2, hour2):
    X_points = np.array([[day1, hour1], [day2, hour2]])
    cov_matrix = gp_model.kernel_(X_points)
    var1 = np.sqrt(cov_matrix[0, 0])
    var2 = np.sqrt(cov_matrix[1, 1])
    correlation = cov_matrix[0, 1] / (var1 * var2) if var1 * var2 != 0 else 0
    return correlation

corr_7_8 = compute_correlations(gp_model, day1=0, hour1=7, day2=0, hour2=8)
print(f"קורלציה בין יום ראשון 07:00-08:00 ל-08:00-09:00: {corr_7_8:.4f}")
corr_7_19 = compute_correlations(gp_model, day1=0, hour1=7, day2=0, hour2=19)
print(f"קורלציה בין יום ראשון 07:00-08:00 ל-19:00-20:00: {corr_7_19:.4f}")
print("הקורלציה בין 07:00-08:00 ל-08:00-09:00 גדולה יותר" if corr_7_8 > corr_7_19 else "הקורלציה בין 07:00-08:00 ל-19:00-20:00 גדולה יותר")
print("תוצאה זו הגיונית מאחר וקצבי הגעה בשעות סמוכות צפויים להיות בעלי דפוסים דומים יותר מאשר בשעות מרוחקות, בשל תלות זמנית חזקה יותר בשעות עוקבות.")

"""## Part 3:

### This is a competative part.

### We have completed the arrival rate predictions by now.

### Now we wish to use them for prediciting the Expected number of patients in the system as a function of time.

### All you need to do is create a dataframe with results in the following manner.

### Upload n_true and df_res.

### n_true is the true expceted number of customers in the system.

### df_res is a dataframe with three columns: hour, day and rate. Currently the rate column is with zeros, you need to fill in your predicted rates from the GP regression and then execute the function plot_results.

### The function will visulize your estimated expected number of customers as a function of time agaisnt the true values (from n_true).

### The fucntion will also print the MSE, the team with lowest MSE wins.

### The bonous points are as follows:

### $1^{st}$ place 5 points bonus.
### $2^{nd}$ place  3 points bonus.
### $3^{rd}$ place  1 point bonus.

## May the best team win!!
"""

n_true = pkl.load(open('/content/drive/MyDrive/PROJECT_BAYES/n_true.pkl', 'rb'))
df_res = pkl.load(open('/content/drive/MyDrive/PROJECT_BAYES/res_template.pkl', 'rb') )
df_res.head()

import pickle
import pandas as pd



# עדכון עמודת rate עם התחזיות מה-GP regression
for idx, row in df_res.iterrows():
    day = row['day']
    hour = row['hour']
    rate_pred = full_rates_df[
        (full_rates_df['day'] == day) &
        (full_rates_df['hour'] == hour)
    ]['rate'].values[0]
    df_res.at[idx, 'rate'] = rate_pred
df_res['rate'] = df_res['rate'].astype(float)

# הפעלת plot_results עם סדר פרמטרים נכון
plot_results(df_res, n_true)

"""### Currently all the rates are 0 values, you need to fill in  your predictions.


"""